%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{new_tlp}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{color}
%\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% J.Garea definitions
\usepackage{caption}
\usepackage{textcomp}
\newcommand{\textapprox}{\raisebox{0.5ex}{\texttildelow}}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{listings}
\usepackage{fancyvrb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{IEEEtrantools}
\usepackage{enumitem}
\usepackage{krudces-main}
\usepackage{krudces-thm}
\usepackage{krudces-thme}

\usepackage{krudces-notation}

\newcommand{\sidecomment}[1]{\marginpar{\footnotesize \emph{\color{blue} #1}}}
%\newcommand{\sidecomment}[1]{}
\newcommand{\pedro}[1]{{\color{red} #1}}

\definecolor{darkred}{rgb}{0.8,0,0.2}
\newcommand{\review}[2]{{\color{darkred}\marginpar{\footnotesize {\color{darkred} #1}}#2}}
\newcommand{\rev}[1]{\emph{\color{blue} #1}}
\newcommand{\change}[1]{{\color{darkred} #1}}
\def\rel{\unlhd}
\def\K{\mathbf{K}\, }
\def\M{\mathbf{M}\, }
\let\sneg\relax
\newcommand{\sneg}{\ensuremath{\text{-}}}
\def\eclingo{{\tt eclingo}}
\def\\wviews{{\tt \wviews}}

\def\sM{\mathcal{M}}
\def\Atoms{\mathit{Atoms}}
\def\Atom{\mathit{Atom}}
\def\mAtoms{\mathit{mAtoms}}
\def\nmAtoms{\mathit{nmAtoms}}
\def\Lit{\mathit{Lit}}

\def\SM{\text{\rm SM}}
\def\AS{\text{\rm AS}}
\newcommand\wv{\mathbb{W}}
\newcommand\wx{\mathbb{X}}
\def\cS{\mathcal{S}}
\newcommand\cset[1]{[#1]}
\newcommand\us{\mathbb{S}}
\newcommand\kdint[2]{({#2, #1})}
\newcommand\kdhtint[2]{({#2, #1})}
\def\Bodym{\mathit{Body}_{sub}}
\def\Bodyr{\mathit{Body}_{obj}}
\def\Head{\mathit{Head}}
\def\Body{\mathit{Body}}
\def\Bodyp{\mathit{Body}^{+}}
\def\Bodyn{\mathit{Body}^{-}}
\def\Bodyrp{\mathit{Body}^+_{ob}}
\def\Bodymp{\mathit{Body}^+_{sub}}
\def\bL{\K}
\def\clingo{{\tt clingo}}
\def\wviews{{\tt wviews}}
\def\EPASP{{\tt EP-ASP}}
\def\eligible{\mathit{eligible}}
\def\minority{\mathit{minority}}
\def\high{\mathit{high}}
\def\fair{\mathit{fair}}
\def\interview{\mathit{interview}}
\def\appointment{\mathit{appointment}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\submitted{21 June 2009}
\revised{}
\accepted{}
\title[A solver for Epistemic Specifications]
    {A solver for Epistemic Specifications under Gelfond 1991 semantics\thanks{Partially supported by MINECO, Spain, grant TIC2017-84453-P}}

  \author[P. Cabalar, J. Fandinno, J. Garea, J. Romero and T. Schaub]
         {Pedro Cabalar$^1$, Jorge Fandinno$^2$, Javier Garea$^1$, Javier Romero$^2$ and Torsten Schaub$^2$\\
          $^1$ Department of Computer Science and IT,
          University of Corunna, Corunna, Spain.\\
          {\email{\{cabalar,javier.garea\}@udc.es}}\\\\
          $^2$ University of Potsdam, Germany\\
          {\email{\{fandinno,javier,torsten\}@uni-potsdam.de}}\\
        }

%\pagerange{\pageref{firstpage}--\pageref{lastpage}}
%\volume{\textbf{10} (3):}
%\jdate{month*** 2006}
%\setcounter{page}{1}
%\pubyear{2006}

\maketitle

\begin{abstract}
We describe \eclingo, a solver for epistemic specifications under Gelfond 1991 semantics built upon the Answer Set Programming system \clingo.
The input language of \eclingo\ uses the syntax extension capabilities of \clingo{} to define subjective literals that, as usual in
epistemic specifications, allow for checking the truth of a regular literal in all or in some of the answer sets of a program.
The \eclingo\ solving process follows a guess and check strategy.
It first generates potential truth values for subjective literals and, in a second step, it checks the obtained result with respect to the cautious and brave consequences of the program.
This process is implemented using the multi-shot functionalities of \clingo.
We have also implemented some optimisations, aiming at reducing the search space and, therefore, increasing \eclingo's efficiency in some scenarios.
Finally, we compare the efficiency of \eclingo\ with two state-of-the-art solvers for epistemic specifications on a pair of benchmark scenarios
and show that \eclingo\ generally outperforms their obtained results.
\end{abstract}
\begin{keywords}
Answer Set Programming, Epistemic Specifications, Non-Monotonic Reasoning, Conformant Planning.
\end{keywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The language of \emph{epistemic specifications} (or epistemic logic programs), proposed by~\citeN{gelfond91a}, is an extension of disjunctive logic programming that introduces modal constructs to quantify over the set of stable models~\cite{gellif88b} of a program.
%
These new constructs, called \emph{subjective literals}, have the form~$\K l$ and~$\M l$ where $l$ is an \emph{objective literal}~$l$, that is, an atom $p$ or its explicit negation $\sneg p$.
%
Intuitively, $\K l$ and~$\M l$ respectively mean that $l$ is true in every stable model (cautious consequence) or in some stable model (brave consequence) of the program.
%
In many cases, these subjective literals can be seen as simple queries, but what makes them really interesting is their use in rule bodies,
which may obviously affect the set of stable models they are quantifying.
%
This feature makes them suitable for modelling introspection but, at the same time, may involve cyclic specifications whose intuitive behaviour is not always easy to define.
%
In general, the semantics of an epistemic logic program may yield alternative sets of stable models, each set being called a \emph{world view}.
%
For instance, the epistemic program
\begin{eqnarray}
p \leftarrow \Not \, \K q \hspace{80pt}
q \leftarrow \Not \, \K p  \label{f:epiloop}
\end{eqnarray}
%
yields two world views $\{\{p\}\}$ and $\{\{q\}\}$, each one with a single stable model.
%
Deciding the intuitive world views of a cyclic specification has motivated a wide debate in the literature.
%
This was mostly due to the fact that Gelfond's original \mbox{semantics (G91;~\citeNP{gelfond91a})} manifests a kind of self-supportedness or \emph{unfoudedness} typically illustrated by the epistemic program
\begin{eqnarray}
p \leftarrow \K p \label{f:selfsupport}
\end{eqnarray}
whose G91 world views are $\{\emptyset\}$ (as expected) but also $\{\{p\}\}$, which seems counterintuitive.
%
Other semantics~\cite{kawabagezh15,faheir15a,sheeit17a} managed to deal with this and other examples but fail to satisfy the elementary splitting property presented in~\cite{cafafa19a}, something that was preserved by the original G91.
%
Moreover, a first formalisation of foundedness was provided in~\cite{cafafa19b} and all the previously existing semantics violated that condition, except the new approach presented in that paper, FAAEL, which corresponds to a strengthening of G91 plus an extra foundedness checking.
%
Thus, to the best of our knowledge, FAAEL is the only semantics satisfying both splitting and foundedness up to date.

There exist several implemented solvers for epistemic specifications -- a recent survey was presented in~\cite{leckah18}.
%
Although there is no solver for FAAEL yet, the closest existing tools are those based on G91, since FAAEL and G91 coincide in all epistemic specifications whose subjective literals do not form positive cycles.
%
This suggests that a solver for FAAEL can be constructed by applying an extra founded checking on top of a G91 solver.
%
In fact, all practical scenarios in the literature involving epistemic problems can be represented without positive subjective cycles, so their computation in terms of G91 is sound with respect to FAAEL too.

In this paper, we present the \eclingo{} system, a solver for epistemic specifications under the G91 semantics.
%
The tool is built on top of the ASP solver {\tt clingo}~\cite{gekakaosscwa16a}
making use of its features for syntactic extensions and multi-shot solving \cite{gekakasc17a}.
%
The basic strategy applied by \eclingo{} is a guess-and-check method where the truth value of subjective literals is first guessed with choice rules for auxiliary atoms and, in a second step, the obtained values for those atoms is checked using the sets of cautious and brave consequences of the program.
%
This basic strategy has been improved with several optimisations.
%
We have made experiments on several scenarios for a pair of benchmark domains and compared to \wviews~\cite{Kelly07} (another solver for G91) and {\tt \EPASP}~\cite{SLKL17}, that computes a close semantics~\cite{kawabagezh15} also accepted by \eclingo{}, outperforming these tools in most cases.

%\red The rest of the paper is organised as follows. \dots \black



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
\label{sec:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We assume some familiarity with the answer set semantics~\cite{GL91} for logic programs.
%
Given a set of atoms $\At$, an \emph{objective literal} is either an atom, a truth constant\footnote{For a simpler description of program transformations, we allow truth constants where $\top$ denotes true and $\bot$ denotes false. These constants can be easily removed.}, that is \mbox{$a \in \At \cup \{\top,\bot\}$}, or an atom preceded by one or two occurrences of default negation,
\mbox{$\Not a$}.
%
We assume that, for each atom $a \in \At$, we have another atom `$\sneg a$' $ \in \At$ that stands for the explicit negation of $a$.
%
As usual, the answer sets of a standard program $\Pi$, denoted as $\AS[\Pi]$, are those stable models of $\Pi$ that do not contain any pair $\{a, -a\}$.
%
The syntax of epistemic specifications is an extension of ASP.
%
An expression of the form $\K l$, $\M l$ with $l$ an objective literal, receives the name of \emph{subjective atom}.
%
A \emph{subjective literal} can be a subjective atom $A$ or its default nefation $\Not A$.
%
A \emph{rule} is an expression of the form:
\begin{gather}
a_1 \vee \dots \vee a_n \leftarrow L_1, \dots, L_m
	\label{eq:rule}
\end{gather}
with $n\geq 0$ and $m\geq 0$, where each $a_i \in \At$ is an atom and each $L_j$ a literal of any kind, either objective or subjective.
%
An \emph{epistemic program} (or epistemic specification) is a set of rules.

\begin{definition}[Subjective reduct]
The \emph{subjective reduct} of an epistemic program $\Pi$ with respect to a set of propositional interpretations~$\wv$, written $\Pi^\wv$, is obtained by replacing each subjective literal $L$ by: $\top$ if $\wv \models L$; or by $\bot$ otherwise.\qed
\end{definition}

Note that the subjective reduct of an epistemic program does not contain subjective literals, and so, it is a standard logic program.
%
Therefore, we can collect its answer sets $\AS[\Pi^\wv]$.
%
We say that a set of propositional interpretations $\wv$ is a \emph{world view} of an epistemic program $\Pi$ if $\wv=\AS[\Pi^\wv]$.
%
Originally, \cite{gelfond91a} allowed empty world views $W=\emptyset$ when the program has no answer sets, rather than leaving the program without world views.
%
Since this feature is not really essential, we exclusively refer to non-empty world views in this paper.
%
The complexity for deciding whether an epistemic program has a world view is $\Sigma^{P}_{3}$~\cite{truszczynski11b}, that is, one level higher in the polynomial hierarchy than  (disjunctive) ASP complexity $\Sigma^{P}_{2}$.

We conclude this section introducing a well-known example introduced in~\cite{gelfond91a}.

\begin{example}\label{ex:college}
A given college uses the following set of rules to decide whether a student $X$ is eligible for a scholarship:
\begin{eqnarray}
\eligible(X) & \leftarrow & \high(X)   \label{ex:college.1} \\
\eligible(X) & \leftarrow & \minority(X),\, \fair(X) \label{ex:college.2}\\
\sneg\eligible(X) & \leftarrow & \sneg\fair(X),\, \sneg\high(X) \label{ex:college.3}
\end{eqnarray}
Here, `$\sneg$' stands for strong negation and $\high(X)$ and $\fair(X)$ refer to the grades of student $X$.
We want to encode the additional college criterion
% \begin{quote}
``\emph{The students whose eligibility is not determined by the college rules should be interviewed by the scholarship committee}''
% \end{quote}
as the epistemic rule:
\begin{eqnarray}
\begin{IEEEeqnarraybox}{rCl}
\interview(X) &\leftarrow  &\Not \K \eligible(X),\,
\Not \K \sneg \eligible(X)
\end{IEEEeqnarraybox}
\label{ex:college.5}
\end{eqnarray}
\qed
\end{example}
For instance, if the only available information for some student $mike$ is the disjunction
\begin{gather}
\fair(mike) \vee \high(mike) \label{ex:college.4}
\end{gather}
then the epistemic program \eqref{ex:college.1}-\eqref{ex:college.4} has a unique world view whose answer sets are
\begin{eqnarray}
&\{\fair(mike),\interview(mike)\}& \label{f:sm1}\\
&\{\high(mike), \eligible(mike),\interview(mike)\} &\label{f:sm2}
\end{eqnarray}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using \texttt{eclingo}}
\label{sec:input}

As said before, \eclingo{} is based on {\tt clingo}'s facilities (through the Python API) for syntax extension and multi-shot solving.
%
As a result, \eclingo{} input language is just a minor extension of the input language accepted by {\tt gringo}~\cite{gekaosscth09a}, the grounder used by {\tt clingo}. In this way, \eclingo{} programs can be constructed with three different types of statements: \emph{rules}, \emph{show} statements and \emph{constant} definitions.

The structure of a clingo rule is as follows:
\begin{align*}
    H_1,\dots,H_m \ \mathtt{:\!-} \ B_1,\ \dots ,\ B_n.
\end{align*}
where the head is formed by $H_i$ \clingo{} literals (commas in the head represent a disjunction) and the body consists of elements $B_i$ that can be \clingo{} literals or subjective literals.
%
The notation for subjective literals in \eclingo{} is as follows.
%
Any construction $\K l$ is replaced {\tt \&k\{$l$\}} where $l$ is a regular, objective literal, that is, it may combine an atom with default or explicit negation.
%
The only particularity is that default negation inside a {\tt \&k} operator must be represented as $\sim$ (this limitation will be changed in the future).
%
For instance, the subjective literal $\K \Not \, -p$ would be represented in \eclingo{} as \mbox{\tt \&k\{$\sim$ -p\}}.
%
Operator $\M$ is not directly supported by now, although any literal of the form $\M l$ can be represented as {\tt not \&k\{$\sim l$\}}.

For instance, program~\eqref{f:epiloop} is represented in \eclingo{} as:
\begin{Verbatim}[frame=single]
p :- not &k{q}.
q :- not &k{p}.
\end{Verbatim}

Assume that this code is stored in file {\tt program1.lp}.
%
To obtain all world views of the program we just make the call
\begin{verbatim}
eclingo -n 0 program1.lp
\end{verbatim}
getting the result:
\begin{Verbatim}[frame=single]
eclingo version 1.0.0
Solving...
Answer: 1
&k{ p }
Answer: 2
&k{ q }
SATISFIABLE
\end{Verbatim}
As we can see, \eclingo{} obtains the world views of an epistemic program but, for each world view, it does not directly display its whole set of answer sets, but prints instead the list of all true subjective atoms.
%
This is actually enough to determine the world view, whose answer sets can be obtained once all the subjective atoms are replaced by their truth values.
%
AS happens with regular atoms in \clingo{}, the input language of  \eclingo{} provides a {\tt \#show} directive to select those subjective atoms that we want to be displayed in each world view.
%
The syntax for this directive is the same as in \clingo{}
\begin{align*}
    \texttt{\#show p/n.}
\end{align*}
where {\tt p} is the name of some predicate (or its explicit negation) and {\tt n} its arity, that is, the number of arguments.
%
The difference in \eclingo{} is that this directive refers to the predicates used in subjective atoms to be displayed in each world view.
For instance, if we add the line
\begin{align*}
    \texttt{\#show p/0.}
\end{align*}
to our previous example, the information for the second world view would just be empty, since we assume we only want to display subjective literals for atom {\tt p}.

As an illustration, the program \eqref{ex:college.1}-\eqref{ex:college.4} for Example~\ref{ex:college} is represented in \eclingo{} as:
\begin{Verbatim}[frame=single]
eligible(X) :- high(X).
eligible(X) :- minority(X), fair(X).
-eligible(X) :- -fair(X), -high(X).
interview(X) :- not &k{ eligible(X)}, not &k{ -eligible(X)}, student(X).
student(mike).
fair(mike),high(mike).
\end{Verbatim}
where we have just introduced predicate {\tt student} to make variable {\tt X} safe in the epistemic rule for {\tt interview}.
%
The unique world view obtained by \eclingo{} in this example shows an empty list of subjective atoms meaning that both \mbox{\tt \&k\{eligible(mike)\}} and \mbox{\tt \&k\{eligible(mike)\}} are false.
%
If we want to know what happens to predicate {\tt interview} we can add the line
\begin{Verbatim}[frame=single]
#show interview/1.
\end{Verbatim}
to obtain now the output
\begin{Verbatim}[frame=single]
Solving...
Answer: 1
&k{ interview(mike) }
SATISFIABLE
\end{Verbatim}
For future work, we will include an option to expand one or all world views into their sets of answer sets.
%\subsubsection{Constant definitions}
%eclingo delegates the processing of constant definitions to clingo. Thus, it does not provide any syntactical or semantical modification. Both clingo and \eclingo{} define constants under the following structure:
%\begin{align*}
%    \texttt{\#const \emph{name}=\emph{value}.}
%\end{align*}
%where \texttt{\emph{name}} is the name of the constant, and \texttt{\emph{value}} is its value. For example, to specify a constant \texttt{length} with value \texttt{2} we write:
%\begin{align*}
%    \texttt{\#const length=2.}
%\end{align*}

\section{Basic solving process}
\label{sec:impl}
As we have seen, \eclingo{} input language is a minor modification of the one for \clingo{}.
To do so, the system uses \clingo{} API parsing methods for obtaining Abstract Syntax Tree (AST) representation in the form of a Python object. \eclingo{} uses these methods to translate the epistemic program into a standard ASP auxiliary one. The translating process is as follows:
\begin{itemize}
    \item Replace each subjective literal with an auxiliary objective literal.
    \item Remove {\tt \#show} statements from the program and store them for a later phase.
    \item Maintain constant definitions as they are in the input program.
    \item Remove anything else.
    \item Add a choice rule for each auxiliary literal.
\end{itemize}

For G91 semantics, subjective literals are replaced using the following rules:
\begin{align}
    \texttt{\&k\{ \ \emph{atom} \ \}} \ & \mapsto\ \texttt{not\ not\ aux\_\emph{atom}} \label{r:g91_1} \\
    \texttt{not\ \&k\{ \ \emph{atom} \ \}} \ & \mapsto\ \texttt{not\ aux\_\emph{atom}} \label{r:g91_2} \\
    \texttt{\&k\{\ $\sim$ \emph{atom}\  \}}\ & \mapsto\ \texttt{not\ not\ aux\_not\_\emph{atom}} \\
    \texttt{not\ \&k\{\ $\sim$ \emph{atom}\  \}}\ & \mapsto\ \texttt{not\ aux\_not\_\emph{atom}} \\
    \texttt{\&k\{\ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{not\ not\ aux\_sn\_\emph{atom}} \\
    \texttt{not\ \&k\{\ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{not\ aux\_sn\_\emph{atom}} \\
    \texttt{\&k\{\ $\sim$ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{not\ not\ aux\_not\_sn\_\emph{atom}} \\
    \texttt{not\ \&k\{\ $\sim$ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{not\ aux\_not\_sn\_\emph{atom}} \label{r:g91_8}
\end{align}
where \texttt{\emph{atom}} means an objective atom.
%
Then, the choice rule added for each auxiliary atom is just:
\begin{align*}
    \texttt{\{\emph{auxiliary\_atom}\}}.
\end{align*}


The main idea behind the parsing process was to generate an auxiliary representation of the problem that can be used as an input for \clingo. Thus, when asking \clingo to solve this program using its multi-shot feature, it will go returning answer sets in terms of these auxiliary literals. Each configuration of subjective atom values represents a particular world view. Filtering objective literals from \clingo's output, and removing duplicates, we can use these answer sets as a bounded pool of potential solutions.

%\subsection{Solving an epistemic logic program} \label{subsec:solve}
\texttt{eclingo} solves epistemic logic programs following a guess and check strategy. This approach splits the solving process into two phases. In the first one, \eclingo{} generates a set of possible solutions to the original program, feeding clingo with the auxiliary program and filtering the output answer sets. The world view representatives, that is, the auxiliary subjective atoms, are isolated and stored as potential solutions.

In the check phase, \eclingo{} verifies these candidates and filters the subset of false candidates.
This phase verifies a set of 4 properties over each candidate. However, the check cannot be done directly over the literals. Instead, the check is executed over the answer sets of a logic program, created by replacing each auxiliary subjective literal of the auxiliary program with the truth value it takes in the candidate. In this way, after the replacement, \eclingo{} invokes \clingo again with this replaced logic program and verifies the set of properties over the output answer sets. The aforementioned properties are the following:
\begin{enumerate}
    \item For each subjective literal of the form \texttt{\&k\{\emph{literal}\}}, \texttt{\emph{literal}} must be in every answer set.

    \item For each subjective literal of the form \texttt{not \&k\{\emph{literal}\}}, \texttt{\emph{literal}} must not be in every answer set.

    \item For each subjective literal of the form \texttt{\&k\{$\sim$ \emph{literal}\}}, \texttt{\emph{literal}} must not be in any answer set.

    \item For each subjective literal of the form \texttt{not \&k\{$\sim$ \emph{literal}\}}, \texttt{\emph{literal}} must be in some answer set.
\end{enumerate}

As it can be seen, verifying these properties involve reasoning over all the answer sets but, fortunately, this can be done in this case using \clingo{} modes for cautious and brave reasoning. These two modes are rely on basic set operations over the resulting answer sets: intersection and union, respectively. Thus, if we compute the cautious and the brave consequences of the replaced logic program, the aforementioned properties can be easily checked by translating them into:
\begin{enumerate}
    \item For each subjective literal of the form \texttt{\&k\{\emph{literal}\}}, \texttt{\emph{literal}} must be in the cautious consequences.

    \item For each subjective literal of the form \texttt{not \&k\{\emph{literal}\}}, \texttt{\emph{literal}} must not be in the cautious consequences.

    \item For each subjective literal of the form \texttt{\&k\{\textapprox\ \emph{literal}\}}, \texttt{\emph{literal}} must not be in the brave consequences.

    \item For each subjective literal of the form \texttt{not \&k\{\textapprox\ \emph{literal}\}}, \texttt{\emph{literal}} must be in in the brave consequences.
\end{enumerate}

Although \eclingo{} was proposed as a solver for epistemic specifications under G91 semantics, in its 1.0.0 version, it also supports \cite{kawabagezh15} (K15) semantics.
%
Since both semantics are so similar, \eclingo{} can support both of them with a little modification in its parsing process. Thus, when an epistemic logic program is translated to an auxiliary one, a new replacing policy is used in K15 mode. This replacing policy is as follows:
\begin{align*}
    \texttt{\&k\{ \ \emph{atom} \ \}} \ & \mapsto\ \texttt{aux\_\emph{atom},\ \emph{atom}} \\
    \texttt{not\ \&k\{ \ \emph{atom} \ \}} \ & \mapsto\ \texttt{n\_aux\_\emph{atom}}\\
    \texttt{\&k\{\ $\sim$ \emph{atom}\  \}}\ & \mapsto\ \texttt{aux\_not\_\emph{atom},\ not\ atom} \\
    \texttt{not\ \&k\{\ $\sim$ \emph{atom}\  \}}\ & \mapsto\ \texttt{n\_aux\_not\_\emph{atom}} \\
    \texttt{\&k\{\ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{aux\_sn\_\emph{atom},\ -atom} \\
    \texttt{not\ \&k\{\ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{n\_aux\_sn\_\emph{atom}} \\
    \texttt{\&k\{\ $\sim$ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{aux\_not\_sn\_\emph{atom},\ not\ -atom} \\
    \texttt{not\ \&k\{\ $\sim$ {-}\emph{atom}\  \}}\ & \mapsto\ \texttt{n\_aux\_not\_sn\_\emph{atom}}
\end{align*}
where \texttt{\emph{atom}} means an objective atom, and atoms that begin with the \texttt{n\_aux} prefix are new auxiliary atoms.
%
Additionally, for each new auxiliary atom we also include a couple of rules to the program that trigger its truth value. These rules are as follows:
\begin{align*}
    \texttt{n\_aux\_\emph{atom}} \ &\ :-\ \texttt{not\ aux\_\emph{atom}.} \\
    \texttt{n\_aux\_\emph{atom}} \ &\ :-\ \texttt{not\ \emph{atom}.} \\
    \texttt{n\_aux\_not\_\emph{atom}} \ &\ :-\ \texttt{not\ aux\_not\_\emph{atom}.} \\
    \texttt{n\_aux\_not\_\emph{atom}} \ &\ :-\ \texttt{not\ not\ \emph{atom}.} \\
    \texttt{n\_aux\_sn\_\emph{atom}} \ &\ :-\ \texttt{not\ aux\_sn\_\emph{atom}.} \\
    \texttt{n\_aux\_sn\_\emph{atom}} \ &\ :-\ \texttt{not\ {-}\emph{atom}.} \\
    \texttt{n\_aux\_not\_sn\_\emph{atom}} \ &\ :-\ \texttt{not\ aux\_not\_sn\_\emph{atom}.} \\
    \texttt{n\_aux\_not\_sn\_\emph{atom}} \ &\ :-\ \texttt{not\ not\ {-}\emph{atom}.}
\end{align*}
where \texttt{\emph{atom}} means an objective atom and rules are selected by the auxiliary atom in its head.
%
Since there is no need to modify any other part of \eclingo{}, the rest of the implementation is shared by both semantics.


\section{Optimising the solving process}
\label{sec:optim}
Several optimisations have been implemented on top of the basic solving process presented before.
%The direct implementation of the solving method presented before is a supposes a naive approach to solve epistemic logic programs. As we already said, \eclingo{} pretends to meet a high level of efficiency. For this purpose, we propose a set of optimizations or heuristics for this method.
%
A first optimisation is the addition of \emph{consistency constraints}.
%
Notice that, once a subjective atom {\tt \&k\{$lit$\}} is are replaced by an standard auxiliary atoms $aux$, the relation to the original literal is lost.
%
Thus, the guess may produce inconsistent combinations like, for instance, an answer set containing:
\begin{align*}
	\texttt{\{\&k\{\textapprox\ p\}, p\}}
\end{align*}
which is not inconsistent for the semantics of {\tt \&k}.
%The subjective literal means that \texttt{p} is false in every answer set while in this proper one \texttt{p} is true. The same would happen in the opposite situation:
%\begin{align*}
%	\texttt{\{\&k\{p\}\}}
%\end{align*}
%where \texttt{p} must be true in every answer set while in this case, it is false.
%This situation can lead to a bigger set of possible candidates to check, where each check is resolved, as we saw, by a $\Sigma^{P}_{2}$ routine (i.e., an invocation to clingo).
This problem can be avoided by adding, to the program we use for the guess, the following pair of rules per each subjective literal:
\begin{align}
\texttt{:- aux\_\emph{lit}, not \emph{literal}.} \label{r:1} \\
\texttt{:- aux\_not\_\emph{literal}, \emph{literal}.} \label{r:2}
\end{align}
where \texttt{\emph{literal}} is the objective literal that the subjective literal refers to.
%As we can see, rule \eqref{r:1} means that if a literal has to be true in every answer set it also has to be in this one itself. In the same way, rule \ref{r:2} means that if a literal has to be false in every answer set it also has to be in this one itself.
%
This situation improves the efficiency of \eclingo{} in those cases that a world view is only proposed by inconsistent answer sets. We can also agree that these constraints can also help in the guess phase since the set of answer sets produced by this invocation to \clingo tends to be smaller.

%\subsubsection{Completion}
Another optimization approach that \eclingo{} performs consists in extending the auxiliary logic program with a new set of auxiliary rules, which we will call \emph{completion} auxiliary rules. This set of rules tries to resolve indirect dependencies between subjective literals.
The idea of this translation is that, when we have the program rule:
\begin{eqnarray}
p \leftarrow q, \Not \ r, \K s.\label{f:rule1}
\end{eqnarray}
we can safely add the rule
\begin{eqnarray}
\K p \leftarrow \K q, \K \Not \ r, \K s. \label{f:rule1b}
\end{eqnarray}
that may allow us concluding more information once the subjective atoms are replaced by auxiliary ones.
These rules are built taking advantage of the parsing process, where the rules are translated to its auxiliary representation. In this way, every time a rule is translated (i.e., the rule has a subjective literal in the body), a completion auxiliary rule is added to the program. This completion auxiliary rule is a copy of the auxiliary one, where objective literals are replaced under the following policy:
\begin{align*}
    \texttt{\emph{atom}} & \mapsto \texttt{aux2\_\emph{atom}} \\
    \texttt{{-}\emph{atom}} & \mapsto \texttt{aux2\_sn\_\emph{atom}} \\
    \texttt{not \emph{atom}} & \mapsto \texttt{aux2\_not\_\emph{atom}} \\
    \texttt{not {-}\emph{atom}} & \mapsto \texttt{aux2\_not\_sn\_\emph{atom}}
\end{align*}
where \texttt{\emph{atom}} is an objective atom. Note that the subjective literals remain the same. For example, \eqref{f:rule1} in \eclingo{} would be the rule:
\begin{align*}
    \texttt{p\ :-\ q,\ not\ r,\ \&k\{s\}.}
\end{align*}
which we had previously translated as
\begin{align*}
    \texttt{p\ :-\ q,\ not\ r,\ aux\_s.}
\end{align*}
is now completed with the additional rule:
\begin{align*}
    \texttt{aux2\_p\ :-\ aux2\_q,\ aux2\_not\_r,\ aux\_s.}
\end{align*}
that corresponds to \eqref{f:rule1b} but for auxiliary atoms.

%\subsubsection{Well-Founded Model}
Another optimisation we have also implemented is based on the iterative computation of the well-founded model of the auxiliary guess program.
%semantics is a well-known theory for negation as failure. Roughly, computing the well-founded model of a logic programming consists of partitioning the set of ground atoms into three sets that define its truth value: true, false, and unknown. This partitioning is performed by focusing on the structure of the rules. In this way, an atom is true if it appears alone in the head of a rule and that rule has no body (i.e., it is a fact). Similarly, an atom that does not appear in the head of any rule is considered false, since it is no way to derive it. Finally, the rest of the atoms (i.e., those that cannot be stated as true or false) are categorized as unknown.
%
%The proper definition of the well-founded model of a logic program allows to state some relations between the set of stable models of the logic program and the well-founded model itself. For example:
%\begin{theorem}
%An atom considered true in the well-founded model must belong to every stable model of the program.
%\end{theorem}
%\begin{theorem}
%An atom considered false in the well-founded model must not belong to any stable model of the program.
%\end{theorem}
%
%As can be seen, these properties are easily relatable with the epistemic semantics:
%\begin{theorem}
%The subjective atom Kp holds for every p true in the well-founded model of a logic program.
%\end{theorem}
%\begin{theorem}
%The subjective atom K \textapprox p holds for every p false in the well-founded model of a logic program.
%\end{theorem}
If, instead of computing the answer sets of the program, we just use {\tt gringo} to obtain its well-founded model (WFM), we will get a good estimate of regular atoms that are always true (resp. always false) in all the answer sets of the program.
In particular, if an atom $p$ is true in the well-founded model, then $\K p$ will hold and we can safely add the corresponding auxiliary atom {\tt aux\_p}.
The same happens if atom $p$ is false in the well-founded model: we conclude $\K \Not \, p$ and add the auxiliary atom {\tt aux\_not\_p}.
%
Thus, computing the well-founded model of the auxiliary logic program before performing the guess-and-check process can help us to deduce trivial subjective literal truth values. These true subjective literals are added to the guess program to reduce the search space. \eclingo{} implements this behaviour in an iterative strategy, computing this well-founded model after the addition of the facts, looping until no new knowledge is found with this method. This iterative execution can be seen in Algorithm \ref{alg:wfm}.
Computing the well-founded model of a logic program takes a quadratic complexity in the general case, while computing the stable models of a logic program is $\Sigma^{P}_{2}$. This difference makes this heuristic a worthy strategy. One more time, \eclingo{} delegates the computation of this well-founded model to {\tt gringo} (i.e., {\tt clingo}'s grounder), which performs this computation during the grounding process. Thus, \eclingo{} performs this optimisation taking advantage of the mandatory grounding phase.

\begin{algorithm}[H]
\SetAlgoLined
test := true; \\
\While{test}{
    ground();\\
    facts := get\_facts();\\
    irrelevants := get\_irrelevants();\\
	\ForEach{fact $f_i \in facts$}{
	    add\_rule($\&k\{f_i\}$.);\\
	}
	\ForEach{irrelevant $i_j \in irrelevants$}{
	   add\_rule($\&k\{ \textapprox\ i_j\}$.);\\
	}
	\If{is\_empty(facts) $\land$ is\_empty(irrelevants)}{
	    test := false;
	}
}
\caption{Extending an epistemic logic program using its WFM.}
\label{alg:wfm}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation and comparison to other solvers}
\label{sec:eval}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we compare \eclingo{} with other two epistemic solvers, \wviews~\cite{Kelly07} and \EPASP~\cite{SLKL17}, both with respect to usability and efficiency.

%\subsection{Input Language}
%\subsubsection{\wviews}
The tool \wviews\footnote{\url{https://github.com/galactose/\wviews}} is a solver for epistemic specifications under G91 semantics developed by Michael Kelly for its Honour's Thesis. It is built upon the ASP system {\tt DLV} and allows the inclusion of subjective literals under a pretty simple notation. However, this simplicity is eclipsed by the limitations in the rest of its grammar. For instance, \wviews{} has no advanced options for specifying constants, show directives, aggregates or conditional literals, among others. Besides, the parser is very sensitive to minor changes in a same problem representation. In fact, we were not able to execute \wviews{} on programs with predicates with more than one argument, something that forced us to test the benchmarks for planning on ground programs.

%\subsubsection{\EPASP}
\EPASP\footnote{\url{https://github.com/tiep/EP-ASP}}~\cite{SLKL17} is another solver for epistemic specifications that can compute world views under two semantics: \cite{kawabagezh15} (K15)  (also computed by \eclingo{}) and~\cite{sheeit17a}. Just like \eclingo{}, it is built upon the ASP system \clingo, but under its 4.5.0 version. \EPASP{} input programs are generated using another independent and non-integrated tool, {\tt ELPS}~\cite{BK14}, that provides a method to translate an epistemic logic program with sort definitions into a standard ASP program. The grammar that defines a correct input program for {\tt ELPS} is, therefore, substantially different from the one used by \clingo{}. It considers four types of statements: directives, sort definitions, predicate declarations and rules. Directives can be either a constant definition or a {\tt maxint} declaration, so the range for numerical expressions is predefined, unlike in \clingo{}.
%Regarding the rest of the program, subjective literals can be included in the body of the rules under a pretty simple syntax.

%the need of the independent and non-integrated tool {\tt ELPS} can be seen as a disadvantage, diusing two different, not fully integrated programs for solving the epistemic logic program can be seen as a difficulty in its usage. Also, while this epistemic logic program represents subjective literals in a very comfortable way, the way it is split makes the representation of the rest of the program a hard task.

Regarding the efficiency comparison, we have executed the three tools (i.e., \wviews, \EPASP{} and \texttt{eclingo}) on scenarios for two well-known problems in the literature: the eligibility problem (Example~\ref{ex:college}) and a variant of the Yale Shooting problem with incomplete knowledge about the initial state, looking for a conformant plan (that is, a plan that always succeeds, regardless of the initial state).
%
Since the three tools have different dependencies, their installation in the same machine was unfeasible. For this reason, a set of \texttt{Amazon Web Services}~\footnote{\url{https://aws.amazon.com/}} virtual machines have been used. These virtual machines are instances of type \texttt{t2.micro}, whose technical specifications are:

\begin{itemize}
\item \textbf{vCPUs:} 1
\item \textbf{Cores:} 1
\item \textbf{Sustained clock speed (GHz):} 2.5
\item \textbf{Memory (MiB):} 1024
\end{itemize}
The chosen operative system is an Ubuntu Server 18.04 LTS, given as an AMI \footnote{Ubuntu Server 18.04 LTS (HVM) 64-Bit(x86). AMI ID: \texttt{ami-07ebfd5b3428b6f4d}}, this is, an \emph{Amazon Machine Image}.
%
%The selected problems for the benchmarking are the Scholarship Eligibility Problem, since it is the first problem upon epistemic specifications were proposed, and the epistemic version of the Yale Shooting Problem, to see how the tools face a harder problem as conformant planning is.

Encodings can be downloaded from the git repository. It is important to note that \EPASP{} encodings are already preprocessed by {\tt ELPS}, so our execution times do not consider this translation step.

Table \ref{tab:eligible} shows best execution time for 10 runs of the Scholarship Eligibility Problem by \wviews{} under G91 semantics, \EPASP{} under K15 semantics and \eclingo{} under both G91 and K15 semantics, to make a fair comparison. In this problem, the tools were fed with 25 scenarios denoted as eligibleXX were XX is the number of the instance and, at the same time, the number of students for the problem. As it can be seen, \wviews{} can only solve the first 7 scenarios (with a timeout of 2 minutes) and only performs better than \eclingo{} in the first one. The performance of \eclingo{} is more solid, solving all the instances with  homogeneous execution times between 0.045s and 0.065s. In the case of \EPASP{} using K15, the tool solves 16 scenarios and reaches the timeout for the 9 remaining ones. For the first 9 scenarios (with the exception of eligible06), \EPASP{} execution times are better, but very close to those thrown by \eclingo{}. However, in the examples from 10 to 16 the performance of \EPASP{} is clearly worse and, moreover, shows an unpredictable variability among the solved cases, from 0.088s in eligible16 to 52.69s for eligible12. \eclingo{} under K15 solves the 25 scenarios in a range of times from 0.046s to 0.073s, being eligible25 an exception with a time of 0.789s.

\begin{table}[ht]
    \begin{tabular}{c|rr|rr}
    \hline
    & \texttt{\wviews{} G91} & \texttt{eclingo G91} & \texttt{\EPASP{} K15} & \texttt{eclingo K15} \\ \hline
    \texttt{eligible01} & {\bf 0.029}      & 0.045       & {\bf 0.027}      & 0.046       \\
    \texttt{eligible02} & 0.049      & {\bf 0.046}       & {\bf 0.028}      & 0.047       \\
    \texttt{eligible03} & 0.128      & {\bf 0.046}       & {\bf 0.028}      & 0.047       \\
    \texttt{eligible04} & 0.462      & {\bf 0.046}       & {\bf 0.029}      & 0.048       \\
    \texttt{eligible05} & 1.824      & {\bf 0.047}       & {\bf 0.034}      & 0.049       \\
    \texttt{eligible06} & 8.230      & {\bf 0.047}       & 0.211      & {\bf 0.049}       \\
    \texttt{eligible07} & 40.467     & {\bf 0.048}       & {\bf 0.040}      & 0.050       \\
    \texttt{eligible08} & -          & {\bf 0.049}       & {\bf 0.042}      & 0.051       \\
    \texttt{eligible09} & -          & {\bf 0.049}       & {\bf 0.046}       & 0.053       \\
    \texttt{eligible10} & -          & {\bf 0.050}       & 2.587      & {\bf 0.054}       \\
    \texttt{eligible11} & -          & {\bf 0.052}       & 13.649     & {\bf 0.058}       \\
    \texttt{eligible12} & -          & {\bf 0.055}       & 52.698     & {\bf 0.059}       \\
    \texttt{eligible13} & -          & {\bf 0.055}       & 1.443      & {\bf 0.061}       \\
    \texttt{eligible14} & -          & {\bf 0.056}       & 15.000     & {\bf 0.062}      \\
    \texttt{eligible15} & -          & {\bf 0.056}       & 0.090      & {\bf 0.062}       \\
    \texttt{eligible16} & -          & {\bf 0.052}       & 0.088      & {\bf 0.076}       \\
    \texttt{eligible17} & -          & {\bf 0.053}       & -          & {\bf 0.058}       \\
    \texttt{eligible18} & -          & {\bf 0.054}       & -          & {\bf 0.058}       \\
    \texttt{eligible19} & -          & {\bf 0.055}       & -          & {\bf 0.066}       \\
    \texttt{eligible20} & -          & {\bf 0.056}       & -          & {\bf 0.068}       \\
    \texttt{eligible21} & -          & {\bf 0.056}       & -          & {\bf 0.072}       \\
    \texttt{eligible22} & -          & {\bf 0.058}       & -          & {\bf 0.068}       \\
    \texttt{eligible23} & -          & {\bf 0.059}       & -          & {\bf 0.070}       \\
    \texttt{eligible24} & -          & {\bf 0.060}       & -          & {\bf 0.073}       \\
    \texttt{eligible25} & -          & {\bf 0.065}       & -          & {\bf 0.789}       \\ \hline
    \end{tabular}
\caption{Eligibility Problem. Time in seconds: timeout fixed in 120s.}
\label{tab:eligible}
\end{table}

Table \ref{tab:yale} shows best execution time for 10 runs of the epistemic version of the Yale Shooting Problem by \EPASP{} under K15 semantics and \eclingo{} under G91 semantics. For this problem, 12 instances were provided. This comparison is less accurate than the eligibility example for several reasons. First, we have used two slightly different problem encodings. For \EPASP{}, we directly used the benchmarks provided with the tool, already translated from {\tt ELPS}, and applied the K15 semantics. Moreover, we used the recommended \EPASP{} configuration for planning. In this special configuration, \EPASP{} recognizes the action theory representation (fluents, actions, goals, etc) and is capable of applying planning based heuristics. In particular, \EPASP{} solves first the problem as a regular planning domain, and then uses this result to prune the search space for the conformant planning problem. For \eclingo{} we redesigned the epistemic rules in the scenario to use G91 instead, something that, under our understanding, provides a more natural use of the epistemic operators (see~\cite{cafafa19a} for a discussion). Besides, \eclingo{} does not apply any planning-based specific heuristics or optimisation: it treats all the scenarios as regular epistemic specifications\footnote{We also executed \EPASP{} for these benchmarks without using the planning mode, but it produced apparently incoherent results, immediately printing an empty world view.}.

As we can see in Table \ref{tab:yale}, \EPASP{} in planning mode performs slightly better than \eclingo{} in all the cases solved by both tools. However, \EPASP{} reaches the timeout in three scenarios for path length 10, while \eclingo{} solves all of them.
\begin{table}[ht]
    \begin{tabular}{c|cc|c}
    \hline
           & \texttt{\EPASP{} K15, planning mode} & \texttt{eclingo G91} & Path length \\ \hline
    \texttt{yale01} & {\bf 0.031}      & 0.053       & 1       \\
    \texttt{yale02} & {\bf 0.033}      & 0.054       & 2       \\
    \texttt{yale03} & {\bf 0.037}      & 0.056       & 3       \\
    \texttt{yale04} & {\bf 0.036}      & 0.057       & 4       \\
    \texttt{yale05} & {\bf 0.045}      & 0.065       & 5       \\
    \texttt{yale07} & {\bf 0.058}      & 0.111       & 7       \\
    \texttt{yale08} & {\bf 0.049}      & 0.075       & 8       \\
    \texttt{yale09} & -          & {\bf 0.492}       & 10      \\
    \texttt{yale10} & {\bf 0.098}      & 0.425       & 10      \\
    \texttt{yale11} & -          & {\bf 0.164}       & 10      \\
    \texttt{yale12} & {\bf 0.174}      & 1.567       & 10      \\
    \texttt{yale13}* & -         & {\bf 0.695}      & 10      \\ \hline
    \end{tabular}
\caption{Yale Shooting Problem. Time in seconds: timeout fixed in 120s. Problem yale13 is unsatisfiable.}
\label{tab:yale}
\end{table}

Due to lack of encodings and the difficulty shown by \wviews{} grammar to represent the epistemic Yale Shooting Problem, we generated a ground version of the problem. Thus, both \wviews{} and \eclingo{} are compared under this ground program. Table \ref{tab:ground_yale} shows best execution time for 10 runs of 12 scenarios of the problem. As we can see, \wviews{} can only solve the first three scenarios while \eclingo{} can still solve all of them, although with generally worse execution times than \eclingo{}Â in the non-ground version (Table \ref{tab:yale}).
This is because when we perform the grounding process independently, we obtain a generally worse result than if we directly run \eclingo{} on the epistemic program containing variables.

%As in the Scholarship Eligibility Problem, \wviews{} does increase its execution time as the number of instance does. While \eclingo{} also increases its execution time progressively, \wviews{} exceeds the timeout at the 4th one.

\begin{table}[ht]
    \begin{tabular}{c|cc|c}
        \hline
                       & \texttt{\wviews{} G91} & \texttt{\eclingo{} G91} & Path length \\ \hline
        \texttt{ground\_yale01} & 0.068      & {\bf 0.047}       & 1       \\
        \texttt{ground\_yale02} & 0.764      & {\bf 0.051}       & 2       \\
        \texttt{ground\_yale03} & 13.694     & {\bf 0.057}       & 3       \\
        \texttt{ground\_yale04} & -          & {\bf 0.062}       & 4       \\
        \texttt{ground\_yale05} & -          & {\bf 0.095}       & 5       \\
        \texttt{ground\_yale07} & -          & {\bf 0.112}       & 7       \\
        \texttt{ground\_yale08} & -          & {\bf 0.159}       & 8       \\
        \texttt{ground\_yale09} & -          & {\bf 0.195}       & 10      \\
        \texttt{ground\_yale10} & -          & {\bf 1.191}       & 10      \\
        \texttt{ground\_yale11} & -          & {\bf 1.201}       & 10      \\
        \texttt{ground\_yale12} & -          & {\bf 4.113}       & 10      \\
        \texttt{ground\_yale13*} & -         & {\bf 3.067}      & 10      \\ \hline
        \end{tabular}
\caption{Ground version of the Yale Shooting Problem. Time in seconds: timeout fixed in 120s. Problem yale13 is unsatisfiable.}
\label{tab:ground_yale}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions and Related Work}
\label{sec:conc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have presented \eclingo{}, a solver for epistemic specifications under~\cite{gelfond91a} semantics, G91.
%
The solver is programmed on top of {\tt clingo}, using its syntactic extension and multi-shot solving features.
%
We have tested the execution of \eclingo{} and compared to other two epistemic solvers in a pair of domains from the literature.
%
The results seem to point out that \eclingo{} provides a better performance, especially in the number of solved scenarios.

Our future work includes the addition of other optimisation techniques and, more importantly, the implementation of an unfoundedness check to disregard self-supported world views that are sometimes produced by G91 semantics (although only on positive cycles), computing in this way the stronger semantics provided in~\cite{cafafa19b}.

\bibliographystyle{acmtrans}
\bibliography{krr,refs,procs}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
